---
parameters:
  - name: serviceName
    type: string

  - name: projectPath
    type: string

  - name: testsProjectPath
    type: string
    default: ''

  - name: infrastructureProjectPath
    type: string
    default: ''

  - name: 'preTest'
    type: stepList
    default: []

  - name: dockerFile
    type: string

  - name: repositoryName
    type: string

  - name: chartPath
    type: string
    default: 'builds/kubernetes/charts'

  - name: chartName
    type: string

  - name: containerRegistry
    type: string
    default: 'aksbootstrap'

  - name: containerRegistryFqdn
    type: string
    default: 'aksbootstrap.azurecr.io'

  # - name: debugPipelineFlow
  #   type: boolean
  #   default: false

stages:

  # ---------------------------------------------------------------------------
  # Build and tests service
  # ---------------------------------------------------------------------------
  - stage: BuildApplication
    displayName: Build Service
    jobs:
      # ---------------------------------------------------------------------------
      # Identify Build context
      # - Calcul the next artefact / docker image version
      # ---------------------------------------------------------------------------
      - job: IdentifyContext
        displayName: Identify build context

        steps:
          - checkout: self
            fetchDepth: 0

          - script: |
              echo "=== D√©but du calcul de version ==="

              # üü¢ D√©tection si le build provient d'une Pull Request
              if [ -n "$SYSTEM_PULLREQUEST_SOURCEBRANCH" ]; then
                echo "Build d√©clench√© par une Pull Request"
                SOURCE_BRANCH_ORIG="${SYSTEM_PULLREQUEST_SOURCEBRANCH#refs/heads/}"
                TARGET_BRANCH_ORIG="${SYSTEM_PULLREQUEST_TARGETBRANCH#refs/heads/}"
                echo "Branche source de la PR : $SOURCE_BRANCH_ORIG"
                echo "Branche cible de la PR : $TARGET_BRANCH_ORIG"
              else
                SOURCE_BRANCH_ORIG="${BUILD_SOURCEBRANCH#refs/heads/}"
                echo "Build sur la branche : $SOURCE_BRANCH_ORIG"
              fi

              # Nettoyage pour la partie metadata (remplacement des caract√®res interdits)
              SOURCE_BRANCH=$(echo "$SOURCE_BRANCH_ORIG" | sed 's/[\/:<>\\|?@*]/-/g')
              TARGET_BRANCH=$(echo "$TARGET_BRANCH_ORIG" | sed 's/[\/:<>\\|?@*]/-/g')

              # üü¢ D√©tection de la branche release cible (formats "release/x.y" ou "releases/x.y")
              if [[ "$SOURCE_BRANCH_ORIG" =~ ^releases?/([0-9]+\.[0-9]+)$ ]]; then
                RELEASE_VERSION="${BASH_REMATCH[1]}"
              elif [[ "$TARGET_BRANCH_ORIG" =~ ^releases?/([0-9]+\.[0-9]+)$ ]]; then
                RELEASE_VERSION="${BASH_REMATCH[1]}"
              else
                RELEASE_VERSION=""
              fi

              if [ -n "$RELEASE_VERSION" ]; then
                # üî• Compter uniquement les merges de PR dans la branche release en filtrant les messages qui contiennent (#xx)
                MERGE_COUNT=$(git log --oneline --first-parent origin/releases/${RELEASE_VERSION} | grep -E '\(#\d+\)' | wc -l)

                # Pour une PR vers une branche release, on anticipe le prochain merge donc on ajoute +1
                if [ -n "$SYSTEM_PULLREQUEST_SOURCEBRANCH" ]; then
                  PATCH=$((MERGE_COUNT + 1))
                else
                  PATCH=$MERGE_COUNT
                fi

                echo "Branche release d√©tect√©e (releases/${RELEASE_VERSION}). Nombre de merges PR d√©tect√©s : $MERGE_COUNT. Nouvelle version calcul√©e: ${RELEASE_VERSION}.${PATCH}"
                NEW_VERSION="${RELEASE_VERSION}.${PATCH}"

              else
                # üî¥ Si aucune branche release sp√©cifique n'est d√©tect√©e, on r√©cup√®re la derni√®re version release globale
                LATEST_RELEASE_VERSION=$(git ls-remote --heads origin "refs/heads/releases/*" "refs/heads/release/*" \
                  | awk '{print $2}' \
                  | sed -E 's#refs/heads/releases?/##' \
                  | sort -V \
                  | tail -n 1)

                if [ -z "$LATEST_RELEASE_VERSION" ]; then
                  echo "Aucune branche release trouv√©e. On part de 0.0.0."
                  LATEST_RELEASE_VERSION="0.0.0"
                fi

                echo "Derni√®re version release trouv√©e: $LATEST_RELEASE_VERSION"
                IFS='.' read -r MAJOR MINOR PATCH <<< "$LATEST_RELEASE_VERSION"

                if [[ "$SOURCE_BRANCH_ORIG" == hotfix/* ]]; then
                  # Pour une branche hotfix, compter les merges de PR dans la release correspondante et ajouter +1
                  PATCH_COUNT=$(git log --oneline --first-parent origin/releases/${MAJOR}.${MINOR} | grep -E '\(#\d+\)' | wc -l)
                  PATCH=$((PATCH_COUNT + 1))
                  NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
                  echo "Branche hotfix d√©tect√©e. Nouvelle version calcul√©e: $NEW_VERSION"

                elif [[ "$SOURCE_BRANCH_ORIG" == feature/* ]]; then
                  MINOR=$((MINOR + 1))
                  PATCH=0
                  NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
                  echo "Branche feature d√©tect√©e. Nouvelle version calcul√©e: $NEW_VERSION"

                elif [[ "$TARGET_BRANCH_ORIG" =~ ^releases?/ ]]; then
                  PATCH=$((PATCH + 1))
                  NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
                  echo "PR vers une branche release d√©tect√©e. Nouvelle version calcul√©e: $NEW_VERSION"

                else
                  MINOR=$((MINOR + 1))
                  PATCH=0
                  NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
                  echo "Branche de d√©veloppement d√©tect√©e. Nouvelle version calcul√©e: $NEW_VERSION"
                fi
              fi

              # R√©cup√©ration du commit court (7 premiers caract√®res)
              COMMIT_SHORT=$(echo $BUILD_SOURCEVERSION | cut -c1-7)
              METADATA=""

              # Construction des metadata pour la version (diff√©rents cas de PR et builds directs)
              if [ -n "$SYSTEM_PULLREQUEST_SOURCEBRANCH" ]; then
                if [[ "$TARGET_BRANCH_ORIG" == "main" || "$TARGET_BRANCH_ORIG" == "master" ]]; then
                  METADATA="pr-${SYSTEM_PULLREQUEST_PULLREQUESTID}.${SOURCE_BRANCH}.${COMMIT_SHORT}"
                elif [[ "$TARGET_BRANCH_ORIG" =~ ^releases?/ ]]; then
                  METADATA="beta-pr-${SYSTEM_PULLREQUEST_PULLREQUESTID}.${SOURCE_BRANCH}.${COMMIT_SHORT}"
                else
                  METADATA="${SOURCE_BRANCH}.${COMMIT_SHORT}"
                fi
              else
                if [[ "$SOURCE_BRANCH_ORIG" == "main" || "$SOURCE_BRANCH_ORIG" == "master" ]]; then
                  METADATA="alpha.${SOURCE_BRANCH}.${COMMIT_SHORT}"
                elif [[ ! "$SOURCE_BRANCH_ORIG" =~ ^releases?/ ]]; then
                  METADATA="${SOURCE_BRANCH}.${COMMIT_SHORT}"
                fi
              fi

              if [ -n "$METADATA" ]; then
                NEW_VERSION="${NEW_VERSION}+${METADATA}"
              fi

              echo "Version finale calcul√©e: $NEW_VERSION"

              # D√©finir la variable de sortie pour qu'elle soit disponible dans le job suivant
              echo "##vso[task.setvariable variable=NEW_VERSION;isOutput=true]$NEW_VERSION"

              echo "=== Fin du calcul de version ==="
            displayName: 'Calculer et d√©finir le num√©ro de version'
            name: SetVersion

# # Job suivant
# - job: NextJob
#   dependsOn: SetVersion
#   variables:
#     VERSION: $[ dependencies.SetVersion.outputs['NEW_VERSION'] ]
#   steps:
#     - script: |
#         echo "Version calcul√©e dans le job pr√©c√©dent: $(VERSION)"
#       displayName: 'Afficher la version dans le job suivant'

#           # - task: CalculateNextVersionTest@1
#           #   name: CalculateNextVersion
#           #   displayName: Determine Version
#           #   inputs:
#           #     configurationLocation: 'configurationPath'
#           #     configurationPath: './VersionManagement.yml'


#           # - task: ReleaseFlowGitVersion@0
#           #   inputs:
#           #     sourceBranch: '$(Build.SourceBranch)'
#           #     updateBuildNumber: true
#           #     # repoRoot: 'xxx'


#       # ---------------------------------------------------------------------------
#       # Build dotnet applications
#       # - Update build number with next version and unique counter
#       # - Build application
#       # ---------------------------------------------------------------------------
#       - job: DotnetBuild
#         displayName: Build Service
#         dependsOn:
#           - IdentifyContext

#         variables:
#           NextVersion: $[ dependencies.IdentifyContext.outputs['CalculateNextVersion.NEW_VERSION'] ]
#           BuildCounter: $[counter(variables['NextVersion'], 0)]

#         steps:
#           - checkout: self
#             fetchDepth: 0

#           - task: PublishBuildNumber@0
#             name: PublishBuildNumber
#             displayName: Publish build numbers
#             inputs:
#               semanticVersioning: '$(NextVersion)'
#               uniqueCounter: '$(BuildCounter)'

#           - template: ./steps/dotnet-ci-steps.yaml
#             parameters:
#               serviceName:       ${{ parameters.serviceName }}
#               projectPath:       ${{ parameters.projectPath }}
#               # debugPipelineFlow: ${{ parameters.debugPipelineFlow }}

#       - ${{ if parameters.testsProjectPath }}:
#         # ---------------------------------------------------------------------------
#         # Execute unit tests
#         # ---------------------------------------------------------------------------
#         - job: DotnetUnitTests
#           displayName: Tests Service
#           dependsOn:
#             - DotnetBuild

#           steps:
#             - template: ./steps/dotnet-unittests-ci-steps.yaml
#               parameters:
#                 serviceName:       ${{ parameters.serviceName }}
#                 projectPath:       ${{ parameters.projectPath }}
#                 testsProjectPath:  ${{ parameters.testsProjectPath }}
#                 preTest:           ${{ parameters.preTest }}
#                 # debugPipelineFlow: ${{ parameters.debugPipelineFlow }}

#   # ---------------------------------------------------------------------------
#   # Build Container image and chart
#   # - Build when Pull request to Master or branch != feature/, topic/, hotfix/
#   # ---------------------------------------------------------------------------
#   - ${{ if or(not(or(startsWith(variables['Build.SourceBranch'],'refs/heads/feature/'), startsWith(variables['Build.SourceBranch'],'refs/heads/topic/'), startsWith(variables['Build.SourceBranch'],'refs/heads/hotfix/'))), and(eq(variables['Build.Reason'],'PullRequest'), eq(variables['System.PullRequest.TargetBranchName'], 'master'))) }}:
#     - stage: BuildImages
#       displayName: Build image and chart
#       dependsOn:
#         - BuildApplication

#       jobs:
#         # ---------------------------------------------------------------------------
#         # Build and publish container image
#         # ---------------------------------------------------------------------------
#         - job: DockerBuild
#           displayName: Build and publish docker images
#           variables:
#             tag: $[ stageDependencies.BuildApplication.DotnetBuild.outputs['PublishBuildNumber.CleanedVersion'] ]

#           steps:
#             - template: ./steps/container-ci-steps.yaml
#               parameters:
#                 serviceName:           ${{ parameters.serviceName }}
#                 repositoryName:        ${{ parameters.repositoryName }}
#                 dockerFile:            ${{ parameters.dockerFile }}
#                 dockerTags:            $(tag)
#                 containerRegistry:     ${{ parameters.containerRegistry }}
#                 containerRegistryFqdn: ${{ parameters.containerRegistryFqdn }}
#                 # debugPipelineFlow: ${{ parameters.debugPipelineFlow }}

#         # ---------------------------------------------------------------------------
#         # Build and publish helm chart
#         # ---------------------------------------------------------------------------
#         - job: HelmBuild
#           displayName: Build and publish Helm chart
#           dependsOn:
#             - DockerBuild

#           variables:
#             tag: $[ stageDependencies.BuildApplication.DotnetBuild.outputs['PublishBuildNumber.SemanticVersion'] ]

#           steps:
#             - template: ./steps/chart-ci-steps.yaml
#               parameters:
#                 serviceName:           ${{ parameters.serviceName }}
#                 chartPath:             ${{ parameters.chartPath }}
#                 chartName:             ${{ parameters.chartName }}
#                 chartVersion:          $(tag)
#                 containerRegistry:     ${{ parameters.containerRegistry }}
#                 containerRegistryFqdn: ${{ parameters.containerRegistryFqdn }}
#                 # debugPipelineFlow: ${{ parameters.debugPipelineFlow }}

#   # ---------------------------------------------------------------------------
#   # Build Databases scripts
#   # ---------------------------------------------------------------------------
#   - ${{ if parameters.infrastructureProjectPath }}:
#     - stage: BuildDbScripts
#       displayName: Build database scripts
#       dependsOn:
#         - BuildApplication

#       jobs:
#         - job: DatabaseBuild
#           displayName: Build database scripts
#           variables:
#             tag: $(Build.BuildId)

#           steps:
#             - template: ./steps/databases-ci-steps.yaml
#               parameters:
#                 serviceName:               ${{ parameters.serviceName }}
#                 projectPath:               ${{ parameters.projectPath }}
#                 infrastructureProjectPath: ${{ parameters.infrastructureProjectPath }}
#                 # debugPipelineFlow:         ${{ parameters.debugPipelineFlow }}

